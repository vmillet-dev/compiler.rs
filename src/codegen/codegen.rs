use std::collections::HashMap;
use crate::lexer::TokenType;
use crate::parser::ast::Stmt;
use super::instruction::{Instruction, Operand, Register};
use super::emitter::{Emitter, CodeEmitter, CodeEmitterWithComment};
use super::statement::StatementGenerator;
use super::analyzer::AstAnalyzer;

pub struct Codegen {
    pub label_count: usize,
    pub stack_offset: i32,
    pub locals: HashMap<String, i32>,
    pub local_types: HashMap<String, TokenType>, // Track variable types
    pub output: String,
    pub data_strings: HashMap<String, String>, // To store format strings and their labels
    pub string_label_count: usize, // For unique string labels
}

impl Codegen {
    pub fn new() -> Self {
        Self {
            label_count: 0,
            stack_offset: 0,
            locals: HashMap::new(),
            local_types: HashMap::new(),
            output: String::new(),
            data_strings: HashMap::new(),
            string_label_count: 0,
        }
    }

    pub fn generate(mut self, ast: &[Stmt]) -> String {
        // Assembly file header with metadata
        self.emit_section_header("MINI-C COMPILER GENERATED ASSEMBLY");
        self.emit_comment("Target: x86-64 Windows");
        self.emit_comment("Calling Convention: Microsoft x64");
        self.emit_comment("Generated by: Mini-C Compiler");
        self.emit_line("");
        
        // Assembly directives
        self.emit_comment("Assembly configuration");
        self.emit_line("bits 64");
        self.emit_line("default rel");
        self.emit_line("global main");
        self.emit_line("extern printf");

        // Analysis passes
        self.emit_subsection_header("Analysis Phase");
        self.emit_comment("First pass: collect variable types");
        self.collect_variable_types(ast);
        self.emit_comment("Second pass: collect format strings with type information");
        self.collect_format_strings(ast);

        // Data section
        self.emit_section_header("DATA SECTION - String Literals and Constants");
        self.emit_line("section .data");

        let data_strings_clone = self.data_strings.clone();
        if data_strings_clone.is_empty() {
            self.emit_comment("No string literals found");
        } else {
            for (s, label) in &data_strings_clone {
                let formatted_s = s.replace('\n', "").replace("%f", "%.2f");
                self.emit_comment(&format!("Format string: \"{}\"", s.replace('\n', "\\n")));
                self.emit_line(&format!("    {}: db \"{}\", 10, 0", label, formatted_s));
            }
        }

        // Text section
        self.emit_section_header("TEXT SECTION - Executable Code");
        self.emit_line("section .text");

        for stmt in ast {
            if let Stmt::Function { name, body, .. } = stmt {
                self.generate_function(name, body);
            }
        }

        self.output
    }

    fn generate_function(&mut self, name: &str, body: &[Stmt]) {
        self.emit_subsection_header(&format!("FUNCTION: {}", name));
        self.emit_line(&format!("{}:", name));
        
        // Function prologue
        self.emit_subsection_header("Function Prologue");
        self.emit_instruction_with_comment(Instruction::Push, vec![
            Operand::Register(Register::Rbp)
        ], Some("save caller's frame"));
        self.emit_instruction_with_comment(Instruction::Mov, vec![
            Operand::Register(Register::Rbp), 
            Operand::Register(Register::Rsp)
        ], Some("set up frame"));
        self.emit_instruction_with_comment(Instruction::Sub, vec![
            Operand::Register(Register::Rsp), 
            Operand::Immediate(48)
        ], Some("allocate 48 bytes (16 vars + 32 shadow)"));

        // Initialize function state
        self.emit_subsection_header("Function Body");
        self.stack_offset = 0;
        self.locals.clear();

        // Generate function body
        for stmt in body {
            self.gen_stmt(stmt);
        }

        // Function epilogue
        self.emit_subsection_header("Function Epilogue");
        self.emit_stack_layout_summary();
        
        self.emit_instruction_with_comment(Instruction::Mov, vec![
            Operand::Register(Register::Rsp), 
            Operand::Register(Register::Rbp)
        ], Some("restore stack"));
        self.emit_instruction_with_comment(Instruction::Pop, vec![
            Operand::Register(Register::Rbp)
        ], Some("restore frame"));
        self.emit_instruction_with_comment(Instruction::Ret, vec![], Some("return"));
        
        self.emit_line(""); // Add spacing after function
    }
}

impl Emitter for Codegen {
    fn emit_line(&mut self, line: &str) {
        self.output.push_str(line);
        self.output.push('\n');
    }

    fn emit_comment(&mut self, comment: &str) {
        self.emit_line(&format!("; {}", comment));
    }
}

impl Codegen {
    /// Emit a section header with clear visual separation
    pub fn emit_section_header(&mut self, title: &str) {
        self.emit_line("");
        self.emit_line(&format!("; {}", "=".repeat(60)));
        self.emit_line(&format!("; {}", title));
        self.emit_line(&format!("; {}", "=".repeat(60)));
        self.emit_line("");
    }

    /// Emit a subsection header for better organization
    pub fn emit_subsection_header(&mut self, title: &str) {
        self.emit_line("");
        self.emit_line(&format!("; {}", "-".repeat(40)));
        self.emit_line(&format!("; {}", title));
        self.emit_line(&format!("; {}", "-".repeat(40)));
    }

    /// Emit a detailed comment about register usage
    pub fn emit_register_comment(&mut self, operation: &str, register: &str, purpose: &str) {
        self.emit_comment(&format!("{}: {} -> {}", operation, register, purpose));
    }

    /// Emit a memory operation comment with offset details
    pub fn emit_memory_comment(&mut self, operation: &str, var_name: &str, offset: i32, var_type: &str) {
        self.emit_comment(&format!("{}: {} ({}) at [rbp{}]", operation, var_name, var_type, offset));
    }

    /// Emit a stack operation comment
    pub fn emit_stack_comment(&mut self, operation: &str, bytes: i32, purpose: &str) {
        self.emit_comment(&format!("Stack {}: {} bytes - {}", operation, bytes, purpose));
    }

    /// Emit a function call preparation comment
    pub fn emit_call_prep_comment(&mut self, function: &str, args: &[&str]) {
        self.emit_comment(&format!("Preparing call to {}({})", function, args.join(", ")));
    }

    /// Emit a stack layout summary for debugging
    pub fn emit_stack_layout_summary(&mut self) {
        self.emit_comment("STACK LAYOUT SUMMARY:");
        self.emit_comment("RBP+0  : Saved RBP (caller's frame pointer)");
        self.emit_comment("RBP-48 : RSP (current stack pointer)");
        self.emit_comment("RBP-32 to RBP-1 : Shadow space (32 bytes for Windows x64 ABI)");
        
        if self.locals.is_empty() {
            self.emit_comment("No local variables allocated");
        } else {
            self.emit_comment("Local variables:");
            
            // Collect variable information first to avoid borrowing issues
            let mut var_info: Vec<(String, i32, String)> = Vec::new();
            for (name, &offset) in &self.locals {
                let var_type = self.local_types.get(name)
                    .map(|t| match t {
                        TokenType::Int => "int (4 bytes)",
                        TokenType::FloatType => "float (8 bytes)",
                        TokenType::CharType => "char (1 byte)",
                        _ => "unknown type",
                    })
                    .unwrap_or("unknown type");
                var_info.push((name.clone(), offset, var_type.to_string()));
            }
            
            // Sort by offset (highest address first)
            var_info.sort_by_key(|(_, offset, _)| *offset);
            var_info.reverse();
            
            // Now emit the comments
            for (name, offset, var_type) in var_info {
                self.emit_comment(&format!("RBP{:3} : {} ({})", offset, name, var_type));
            }
        }
        self.emit_line("");
    }

    /// Emit detailed instruction timing information (for advanced debugging)
    pub fn emit_instruction_with_timing(&mut self, instruction: Instruction, operands: Vec<Operand>, cycles: &str) {
        self.emit_instruction(instruction, operands);
        self.emit_comment(&format!("Estimated cycles: {}", cycles));
    }

    /// Emit register state comment for debugging
    pub fn emit_register_state(&mut self, registers: &[(&str, &str)]) {
        self.emit_comment("Register state:");
        for (reg, content) in registers {
            self.emit_comment(&format!("  {} = {}", reg, content));
        }
    }
}